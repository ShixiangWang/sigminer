<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>A Best Practice for Signature Extraction and Exposure (Activity) Attribution — bp • sigminer</title>

<!-- favicons -->
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png" />
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png" />
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png" />
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png" />

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/united/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />


<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="A Best Practice for Signature Extraction and Exposure (Activity) Attribution — bp" />
<meta property="og:description" content="These functions are combined to provide a best practice for optimally
identifying mutational signatures and attributing their activities (exposures)
in tumor samples. They are listed in order to use.
bp_extract_signatures() for extracting signatures.
bp_show_survey() for showing measures change under different
signature numbers to help user select optimal signature number.
At default, an aggregated score (named score) is generated to
suggest the best solution.
bp_show_survey2() for showing simplified signature number survey like
show_sig_number_survey().
bp_get_sig_obj() for get a (list of) Signature object which is common
used in sigminer for analysis and visualization.
bp_attribute_activity() for optimizing signature activities (exposures).
NOTE: the activities from extraction step may be better!
You can also use sig_extract to get optimal NMF result from multiple NMF runs.
Besides, you can use sig_fit to quantify exposures based on signatures extracted
from bp_extract_signatures().
bp_extract_signatures_iter() for extracting signature in a iteration way.
bp_cluster_iter_list() for clustering (hclust with average linkage)
iterated signatures to help collapse
multiple signatures into one. The result cluster can be visualized by
plot() or factoextra::fviz_dend().
bp_get_clustered_sigs() for getting clustered (grouped) mean signatures from signature clusters.
Extra: bp_get_stats() for obtaining stats for signatures and samples of a solution.
These stats are aggregated (averaged) as the stats for a solution
(specific signature number).
Extra: bp_get_rank_score() for obtaining rank score for all signature numbers.

" />
<meta property="og:image" content="/logo.png" />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">sigminer</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.2.5</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/sigminer.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/ShixiangWang/sigminer/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>A Best Practice for Signature Extraction and Exposure (Activity) Attribution</h1>
    <small class="dont-index">Source: <a href='https://github.com/ShixiangWang/sigminer/blob/master/R/best_practice.R'><code>R/best_practice.R</code></a></small>
    <div class="hidden name"><code>bp.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>These functions are combined to provide a best practice for optimally
identifying mutational signatures and attributing their activities (exposures)
in tumor samples. They are listed in order to use.</p><ul>
<li><p><code>bp_extract_signatures()</code> for extracting signatures.</p></li>
<li><p><code>bp_show_survey()</code> for showing measures change under different
signature numbers to help user select optimal signature number.
At default, an aggregated score (named score) is generated to
suggest the best solution.</p></li>
<li><p><code>bp_show_survey2()</code> for showing simplified signature number survey like
<code><a href='show_sig_number_survey.html'>show_sig_number_survey()</a></code>.</p></li>
<li><p><code>bp_get_sig_obj()</code> for get a (list of) <code>Signature</code> object which is common
used in <strong>sigminer</strong> for analysis and visualization.</p></li>
<li><p><code>bp_attribute_activity()</code> for optimizing signature activities (exposures).
NOTE: the activities from extraction step may be better!
You can also use <a href='sig_extract.html'>sig_extract</a> to get optimal NMF result from multiple NMF runs.
Besides, you can use <a href='sig_fit.html'>sig_fit</a> to quantify exposures based on signatures extracted
from <code>bp_extract_signatures()</code>.</p></li>
<li><p><code>bp_extract_signatures_iter()</code> for extracting signature in a iteration way.</p></li>
<li><p><code>bp_cluster_iter_list()</code> for clustering (<code>hclust</code> with average linkage)
iterated signatures to help collapse
multiple signatures into one. The result cluster can be visualized by
<code><a href='https://rdrr.io/r/graphics/plot.default.html'>plot()</a></code> or <code><a href='https://rdrr.io/pkg/factoextra/man/fviz_dend.html'>factoextra::fviz_dend()</a></code>.</p></li>
<li><p><code>bp_get_clustered_sigs()</code> for getting clustered (grouped) mean signatures from signature clusters.</p></li>
<li><p>Extra: <code>bp_get_stats</code>() for obtaining stats for signatures and samples of a solution.
These stats are aggregated (averaged) as the stats for a solution
(specific signature number).</p></li>
<li><p>Extra: <code>bp_get_rank_score()</code> for obtaining rank score for all signature numbers.</p></li>
</ul>

    </div>

    <pre class="usage"><span class='fu'>bp_extract_signatures</span><span class='op'>(</span>
  <span class='va'>nmf_matrix</span>,
  range <span class='op'>=</span> <span class='fl'>2</span><span class='op'>:</span><span class='fl'>5</span>,
  n_bootstrap <span class='op'>=</span> <span class='fl'>20L</span>,
  n_nmf_run <span class='op'>=</span> <span class='fl'>50</span>,
  RTOL <span class='op'>=</span> <span class='fl'>0.001</span>,
  min_contribution <span class='op'>=</span> <span class='fl'>0</span>,
  cores <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>min</a></span><span class='op'>(</span><span class='fl'>4L</span>, <span class='fu'>future</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/future/man/re-exports.html'>availableCores</a></span><span class='op'>(</span><span class='op'>)</span><span class='op'>)</span>,
  cores_solution <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>min</a></span><span class='op'>(</span><span class='va'>cores</span>, <span class='fu'><a href='https://rdrr.io/r/base/length.html'>length</a></span><span class='op'>(</span><span class='va'>range</span><span class='op'>)</span><span class='op'>)</span>,
  seed <span class='op'>=</span> <span class='fl'>123456L</span>,
  handle_hyper_mutation <span class='op'>=</span> <span class='cn'>TRUE</span>,
  report_integer_exposure <span class='op'>=</span> <span class='cn'>FALSE</span>,
  only_core_stats <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/nrow.html'>nrow</a></span><span class='op'>(</span><span class='va'>nmf_matrix</span><span class='op'>)</span> <span class='op'>&gt;</span> <span class='fl'>100</span>,
  cache_dir <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/file.path.html'>file.path</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/tempfile.html'>tempdir</a></span><span class='op'>(</span><span class='op'>)</span>, <span class='st'>"sigminer_bp"</span><span class='op'>)</span>,
  keep_cache <span class='op'>=</span> <span class='cn'>FALSE</span>,
  pynmf <span class='op'>=</span> <span class='cn'>FALSE</span>,
  use_conda <span class='op'>=</span> <span class='cn'>TRUE</span>,
  py_path <span class='op'>=</span> <span class='st'>"/Users/wsx/anaconda3/bin/python"</span>
<span class='op'>)</span>

<span class='fu'>bp_extract_signatures_iter</span><span class='op'>(</span>
  <span class='va'>nmf_matrix</span>,
  range <span class='op'>=</span> <span class='fl'>2</span><span class='op'>:</span><span class='fl'>5</span>,
  sim_threshold <span class='op'>=</span> <span class='fl'>0.95</span>,
  max_iter <span class='op'>=</span> <span class='fl'>10L</span>,
  n_bootstrap <span class='op'>=</span> <span class='fl'>20L</span>,
  n_nmf_run <span class='op'>=</span> <span class='fl'>50</span>,
  RTOL <span class='op'>=</span> <span class='fl'>0.001</span>,
  min_contribution <span class='op'>=</span> <span class='fl'>0</span>,
  cores <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>min</a></span><span class='op'>(</span><span class='fl'>4L</span>, <span class='fu'>future</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/future/man/re-exports.html'>availableCores</a></span><span class='op'>(</span><span class='op'>)</span><span class='op'>)</span>,
  cores_solution <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>min</a></span><span class='op'>(</span><span class='va'>cores</span>, <span class='fu'><a href='https://rdrr.io/r/base/length.html'>length</a></span><span class='op'>(</span><span class='va'>range</span><span class='op'>)</span><span class='op'>)</span>,
  seed <span class='op'>=</span> <span class='fl'>123456L</span>,
  handle_hyper_mutation <span class='op'>=</span> <span class='cn'>TRUE</span>,
  report_integer_exposure <span class='op'>=</span> <span class='cn'>FALSE</span>,
  only_core_stats <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/nrow.html'>nrow</a></span><span class='op'>(</span><span class='va'>nmf_matrix</span><span class='op'>)</span> <span class='op'>&gt;</span> <span class='fl'>100</span>,
  cache_dir <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/file.path.html'>file.path</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/tempfile.html'>tempdir</a></span><span class='op'>(</span><span class='op'>)</span>, <span class='st'>"sigminer_bp"</span><span class='op'>)</span>,
  keep_cache <span class='op'>=</span> <span class='cn'>FALSE</span>,
  pynmf <span class='op'>=</span> <span class='cn'>FALSE</span>,
  use_conda <span class='op'>=</span> <span class='cn'>FALSE</span>,
  py_path <span class='op'>=</span> <span class='st'>"/Users/wsx/anaconda3/bin/python"</span>
<span class='op'>)</span>

<span class='fu'>bp_cluster_iter_list</span><span class='op'>(</span><span class='va'>x</span>, k <span class='op'>=</span> <span class='cn'>NULL</span>, include_final_iteration <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>

<span class='fu'>bp_get_clustered_sigs</span><span class='op'>(</span><span class='va'>SigClusters</span>, <span class='va'>cluster_label</span><span class='op'>)</span>

<span class='fu'>bp_get_sig_obj</span><span class='op'>(</span><span class='va'>obj</span>, signum <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span>

<span class='fu'>bp_get_stats</span><span class='op'>(</span><span class='va'>obj</span><span class='op'>)</span>

<span class='fu'>bp_get_rank_score</span><span class='op'>(</span><span class='va'>obj</span><span class='op'>)</span>

<span class='fu'>bp_show_survey2</span><span class='op'>(</span>
  <span class='va'>obj</span>,
  x <span class='op'>=</span> <span class='st'>"signature_number"</span>,
  left_y <span class='op'>=</span> <span class='st'>"silhouette"</span>,
  right_y <span class='op'>=</span> <span class='st'>"L2_error"</span>,
  left_name <span class='op'>=</span> <span class='va'>left_y</span>,
  right_name <span class='op'>=</span> <span class='va'>right_y</span>,
  left_color <span class='op'>=</span> <span class='st'>"black"</span>,
  right_color <span class='op'>=</span> <span class='st'>"red"</span>,
  left_shape <span class='op'>=</span> <span class='fl'>16</span>,
  right_shape <span class='op'>=</span> <span class='fl'>18</span>,
  shape_size <span class='op'>=</span> <span class='fl'>4</span>,
  highlight <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span>

<span class='fu'>bp_show_survey</span><span class='op'>(</span>
  <span class='va'>obj</span>,
  add_score <span class='op'>=</span> <span class='cn'>FALSE</span>,
  scales <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"free_y"</span>, <span class='st'>"free"</span><span class='op'>)</span>,
  fixed_ratio <span class='op'>=</span> <span class='cn'>TRUE</span>
<span class='op'>)</span>

<span class='fu'>bp_attribute_activity</span><span class='op'>(</span>
  <span class='va'>input</span>,
  sample_class <span class='op'>=</span> <span class='cn'>NULL</span>,
  nmf_matrix <span class='op'>=</span> <span class='cn'>NULL</span>,
  method <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"bt"</span>, <span class='st'>"stepwise"</span><span class='op'>)</span>,
  bt_use_prop <span class='op'>=</span> <span class='cn'>FALSE</span>,
  return_class <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"matrix"</span>, <span class='st'>"data.table"</span><span class='op'>)</span>,
  use_parallel <span class='op'>=</span> <span class='cn'>FALSE</span>,
  cache_dir <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/file.path.html'>file.path</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/tempfile.html'>tempdir</a></span><span class='op'>(</span><span class='op'>)</span>, <span class='st'>"sigminer_attribute_activity"</span><span class='op'>)</span>,
  keep_cache <span class='op'>=</span> <span class='cn'>FALSE</span>
<span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>nmf_matrix</th>
      <td><p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p></td>
    </tr>
    <tr>
      <th>range</th>
      <td><p>a <code>numeric</code> vector containing the ranks of factorization to try. Note that duplicates are removed
and values are sorted in increasing order. The results are notably returned in this order.</p></td>
    </tr>
    <tr>
      <th>n_bootstrap</th>
      <td><p>number of bootstrapped (resampling) catalogs used.
When it is <code>0</code>, the original (input) mutation catalog is used for NMF decomposition,
this is not recommended, just for testing, user should not set it to <code>0</code>.</p></td>
    </tr>
    <tr>
      <th>n_nmf_run</th>
      <td><p>number of NMF runs for each bootstrapped or original catalog.
At default, in total n_bootstrap x n_nmf_run (i.e. 1000) NMF runs are used
for the task.</p></td>
    </tr>
    <tr>
      <th>RTOL</th>
      <td><p>a threshold proposed by Nature Cancer paper to control how to
filter solutions of NMF. Default is <code>0.1%</code> (from reference #2),
only NMF solutions with KLD (KL deviance) &lt;= <code>100.1%</code> minimal KLD are kept.</p></td>
    </tr>
    <tr>
      <th>min_contribution</th>
      <td><p>a component contribution threshold to filer out small
contributed components.</p></td>
    </tr>
    <tr>
      <th>cores</th>
      <td><p>number of cpu cores to run NMF.</p></td>
    </tr>
    <tr>
      <th>cores_solution</th>
      <td><p>cores for processing solutions, default is equal to argument <code>cores</code>.</p></td>
    </tr>
    <tr>
      <th>seed</th>
      <td><p>a random seed to make reproducible result.</p></td>
    </tr>
    <tr>
      <th>handle_hyper_mutation</th>
      <td><p>default is <code>TRUE</code>, handle hyper-mutant samples.</p></td>
    </tr>
    <tr>
      <th>report_integer_exposure</th>
      <td><p>if <code>TRUE</code>, report integer signature
exposure by bootstrapping technique.</p></td>
    </tr>
    <tr>
      <th>only_core_stats</th>
      <td><p>if <code>TRUE</code>, only calculate the core stats for signatures and samples.</p></td>
    </tr>
    <tr>
      <th>cache_dir</th>
      <td><p>a directory for keep temp result files.</p></td>
    </tr>
    <tr>
      <th>keep_cache</th>
      <td><p>if <code>TRUE</code>, keep cache results.</p></td>
    </tr>
    <tr>
      <th>pynmf</th>
      <td><p>if <code>TRUE</code>, use Python NMF driver <a href='http://nimfa.biolab.si/index.html'>Nimfa</a>.
The seed currently is not used by this implementation, so the only way to reproduce
your result is setting <code>keep_cache = TRUE</code>.</p></td>
    </tr>
    <tr>
      <th>use_conda</th>
      <td><p>if <code>TRUE</code>, create an independent conda environment to run NMF.</p></td>
    </tr>
    <tr>
      <th>py_path</th>
      <td><p>path to Python executable file, e.g. '/Users/wsx/anaconda3/bin/python'. In my
test, it is more stable than <code>use_conda=TRUE</code>. You can install the Nimfa package by yourself
or set <code>use_conda</code> to <code>TRUE</code> to install required Python environment, and then set this option.</p></td>
    </tr>
    <tr>
      <th>sim_threshold</th>
      <td><p>a similarity threshold for selecting samples to auto-rerun
the extraction procedure (i.e. <code>bp_extract_signatures()</code>), default is <code>0.95</code>.</p></td>
    </tr>
    <tr>
      <th>max_iter</th>
      <td><p>the maximum iteration size, default is 10, i.e., at most run
the extraction procedure 10 times.</p></td>
    </tr>
    <tr>
      <th>x</th>
      <td><p>result from <code>bp_extract_signatures_iter()</code> or a list of
<code>Signature</code> objects.</p></td>
    </tr>
    <tr>
      <th>k</th>
      <td><p>an integer sequence specifying the cluster number to get silhouette.</p></td>
    </tr>
    <tr>
      <th>include_final_iteration</th>
      <td><p>if <code>FALSE</code>, exclude final iteration result
from clustering for input from <code>bp_extract_signatures_iter()</code>, not applied
if input is a list of <code>Signature</code> objects.</p></td>
    </tr>
    <tr>
      <th>SigClusters</th>
      <td><p>result from <code>bp_cluster_iter_list()</code>.</p></td>
    </tr>
    <tr>
      <th>cluster_label</th>
      <td><p>cluster labels for a specified cluster number, obtain it
from <code>SigClusters$sil_df</code>.</p></td>
    </tr>
    <tr>
      <th>obj</th>
      <td><p>a <code>ExtractionResult</code> object from <code>bp_extract_signatures()</code>.</p></td>
    </tr>
    <tr>
      <th>signum</th>
      <td><p>a integer vector to extract the corresponding <code>Signature</code> object(s).
If it is <code>NULL</code> (default), all will be returned.</p></td>
    </tr>
    <tr>
      <th>left_y</th>
      <td><p>column name for left y axis.</p></td>
    </tr>
    <tr>
      <th>right_y</th>
      <td><p>column name for right y axis.</p></td>
    </tr>
    <tr>
      <th>left_name</th>
      <td><p>label name for left y axis.</p></td>
    </tr>
    <tr>
      <th>right_name</th>
      <td><p>label name for right y axis.</p></td>
    </tr>
    <tr>
      <th>left_color</th>
      <td><p>color for left axis.</p></td>
    </tr>
    <tr>
      <th>right_color</th>
      <td><p>color for right axis.</p></td>
    </tr>
    <tr>
      <th>left_shape</th>
      <td><p>shape setting.</p></td>
    </tr>
    <tr>
      <th>right_shape</th>
      <td><p>shape setting.</p></td>
    </tr>
    <tr>
      <th>shape_size</th>
      <td><p>shape setting.</p></td>
    </tr>
    <tr>
      <th>highlight</th>
      <td><p>a <code>integer</code> to highlight a <code>x</code>.</p></td>
    </tr>
    <tr>
      <th>add_score</th>
      <td><p>if <code>FALSE</code>, don't show score and label optimal points by
rank score.</p></td>
    </tr>
    <tr>
      <th>scales</th>
      <td><p>one of "free_y" (default) and "free" to control the scales
of plot facet.</p></td>
    </tr>
    <tr>
      <th>fixed_ratio</th>
      <td><p>if <code>TRUE</code> (default), make the x/y axis ratio fixed.</p></td>
    </tr>
    <tr>
      <th>input</th>
      <td><p>result from <code>bp_extract_signatures()</code> or a Signature object.</p></td>
    </tr>
    <tr>
      <th>sample_class</th>
      <td><p>a named string vector whose names are sample names
and values are class labels (i.e. cancer subtype). If it is <code>NULL</code> (the default),
treat all samples as one group.</p></td>
    </tr>
    <tr>
      <th>method</th>
      <td><p>one of 'bt' (use bootstrap exposure median, from reference #2,
<strong>the most recommended way in my personal view</strong>) or stepwise'
(stepwise reduce and update signatures then do signature fitting
with last signature sets, from reference #2, the result tends to assign
the contribution of removed signatures to the remaining signatures,
<strong>maybe I misunderstand the paper method? PAY ATTENTION</strong>).</p></td>
    </tr>
    <tr>
      <th>bt_use_prop</th>
      <td><p>this parameter is only used for <code>bt</code> method to reset
low contributing signature activity (relative activity <code>&lt;0.01</code>). If <code>TRUE</code>,
use empirical P value calculation way (i.e. proportion, used by reference <code>#2</code>),
otherwise a <code>t.test</code> is applied.</p></td>
    </tr>
    <tr>
      <th>return_class</th>
      <td><p>string, 'matrix' or 'data.table'.</p></td>
    </tr>
    <tr>
      <th>use_parallel</th>
      <td><p>if <code>TRUE</code>, use parallel computation based on <strong>furrr</strong> package.
It can also be an integer for specifying cores.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>It depends on the called function.</p>
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>The signature extraction approach is adopted from reference #1, #2, and
the whole best practice is adopted from the pipeline used by reference #3.
I implement the whole procedure with R code based on the method description
of papers. The code is well organized, tested and documented so user will
find it pretty simple and useful. Besides, the structure of the results is
very clear to see and also visualize like other approaches provided by <strong>sigminer</strong>.</p>
    <h2 class="hasAnchor" id="measure-explanation-in-survey-plot"><a class="anchor" href="#measure-explanation-in-survey-plot"></a>Measure Explanation in Survey Plot</h2>

    

<p>The survey plot provides a pretty good way to facilitate the signature number
selection. A <code>score</code> measure is calculated as the weighted mean of selected
measures and visualized as the first sub-plot. The optimal number is highlighted
with red color dot and the best values for each measures are also
highlighted with orange color dots. The detail of 6 measures shown in plot are
explained as below.</p><ul>
<li><p><code>score</code> - an aggregated score based on rank scores from selected measures below.
The higher, the better. When two signature numbers have the same score,
the larger signature number is preferred (this is a rare situation, you
have to double check other measures).</p></li>
<li><p><code>silhouette</code> - the average silhouette width for signatures, also named as ASW in reference #2.
The signature number with silhouette decreases sharply is preferred.</p></li>
<li><p><code>distance</code> - the average sample reconstructed cosine distance, the lower value is better.</p></li>
<li><p><code>error</code> - the average sample reconstructed error calculated with L2 formula
(i.e. L2 error). This lower value is better. This measure represents a
similar concept like <code>distance</code> above, they are all used to quantify how well
sample mutation profiles can be reconstructed from signatures, but <code>distance</code>
cares the whole mutation profile similarity while <code>error</code> here cares value difference.</p></li>
<li><p><code>pos cor</code> - the average positive signature exposure correlation coefficient.
The lower value is better. This measure is constructed based on my understanding
about signatures: mutational signatures are typically treated as independent
recurrent patterns, so their activities are less correlated.</p></li>
<li><p><code>similarity</code> - the average similarity within in a signature cluster.
Like <code>silhouette</code>, the point decreases sharply is preferred.
In the practice, results from multiple NMF runs are clustered
with "clustering with match" algorithm proposed by reference #2. This value
indicates if the signature profiles extracted from different NMF runs are similar.</p></li>
</ul>

    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p>Alexandrov, Ludmil B., et al. "Deciphering signatures of mutational processes operative in human cancer." Cell reports 3.1 (2013): 246-259.</p>
<p>Degasperi, Andrea, et al. "A practical framework and online tool for mutational signature analyses show intertissue variation and driver dependencies." Nature cancer 1.2 (2020): 249-263.</p>
<p>Alexandrov, Ludmil B., et al. “The repertoire of mutational signatures in human cancer.” Nature 578.7793 (2020): 94-101.</p>
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p>See <a href='sig_estimate.html'>sig_estimate</a>, <a href='sig_extract.html'>sig_extract</a>, <a href='sig_auto_extract.html'>sig_auto_extract</a>,
<a href='sigprofiler.html'>sigprofiler_extract</a> for other approaches.</p></div>
    <h2 class="hasAnchor" id="author"><a class="anchor" href="#author"></a>Author</h2>

    <p>Shixiang Wang <a href='mailto:w_shixiang@163.com'>w_shixiang@163.com</a></p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><span class='fu'><a href='https://rdrr.io/r/utils/data.html'>data</a></span><span class='op'>(</span><span class='st'>"simulated_catalogs"</span><span class='op'>)</span>
<span class='co'># \donttest{</span>
<span class='co'># Here I reduce the values for n_bootstrap and n_nmf_run</span>
<span class='co'># for reducing the run time.</span>
<span class='co'># In practice, you should keep default or increase the values</span>
<span class='co'># for better estimation.</span>
<span class='co'>#</span>
<span class='co'># The input data here is simulated from 10 mutational signatures</span>
<span class='va'>e1</span> <span class='op'>&lt;-</span> <span class='fu'>bp_extract_signatures</span><span class='op'>(</span>
  <span class='fu'><a href='https://rdrr.io/r/base/t.html'>t</a></span><span class='op'>(</span><span class='va'>simulated_catalogs</span><span class='op'>$</span><span class='va'>set1</span><span class='op'>)</span>,
  range <span class='op'>=</span> <span class='fl'>8</span><span class='op'>:</span><span class='fl'>12</span>,
  n_bootstrap <span class='op'>=</span> <span class='fl'>5</span>,
  n_nmf_run <span class='op'>=</span> <span class='fl'>10</span>
<span class='op'>)</span>


<span class='co'># See the survey for different signature numbers</span>
<span class='co'># The suggested solution is marked as red dot</span>
<span class='co'># with highest integrated score.</span>
<span class='va'>p1</span> <span class='op'>&lt;-</span> <span class='fu'>bp_show_survey</span><span class='op'>(</span><span class='va'>e1</span><span class='op'>)</span>
<span class='va'>p1</span>
<span class='co'># You can also exclude plotting and highlighting the score</span>
<span class='va'>p2</span> <span class='op'>&lt;-</span> <span class='fu'>bp_show_survey</span><span class='op'>(</span><span class='va'>e1</span>, add_score <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>
<span class='va'>p2</span>

<span class='co'># You can also plot a simplified version</span>
<span class='va'>p3</span> <span class='op'>&lt;-</span> <span class='fu'>bp_show_survey2</span><span class='op'>(</span><span class='va'>e1</span>, highlight <span class='op'>=</span> <span class='fl'>10</span><span class='op'>)</span>
<span class='va'>p3</span>

<span class='co'># Obtain the suggested solution from extraction result</span>
<span class='va'>obj_suggested</span> <span class='op'>&lt;-</span> <span class='fu'>bp_get_sig_obj</span><span class='op'>(</span><span class='va'>e1</span>, <span class='va'>e1</span><span class='op'>$</span><span class='va'>suggested</span><span class='op'>)</span>
<span class='va'>obj_suggested</span>
<span class='co'># If you think the suggested signature number is not right</span>
<span class='co'># Just pick up the solution you want</span>
<span class='va'>obj_s8</span> <span class='op'>&lt;-</span> <span class='fu'>bp_get_sig_obj</span><span class='op'>(</span><span class='va'>e1</span>, <span class='fl'>8</span><span class='op'>)</span>

<span class='co'># Track the reconstructed profile similarity</span>
<span class='va'>rec_sim</span> <span class='op'>&lt;-</span> <span class='fu'><a href='get_sig_rec_similarity.html'>get_sig_rec_similarity</a></span><span class='op'>(</span><span class='va'>obj_s8</span>, <span class='fu'><a href='https://rdrr.io/r/base/t.html'>t</a></span><span class='op'>(</span><span class='va'>simulated_catalogs</span><span class='op'>$</span><span class='va'>set1</span><span class='op'>)</span><span class='op'>)</span>
<span class='va'>rec_sim</span>

<span class='co'># After extraction, you can assign the signatures</span>
<span class='co'># to reference COSMIC signatures</span>
<span class='co'># More see ?get_sig_similarity</span>
<span class='va'>sim</span> <span class='op'>&lt;-</span> <span class='fu'><a href='get_sig_similarity.html'>get_sig_similarity</a></span><span class='op'>(</span><span class='va'>obj_suggested</span><span class='op'>)</span>
<span class='co'># Visualize the match result</span>
<span class='kw'>if</span> <span class='op'>(</span><span class='kw'><a href='https://rdrr.io/r/base/library.html'>require</a></span><span class='op'>(</span><span class='va'>pheatmap</span><span class='op'>)</span><span class='op'>)</span> <span class='op'>{</span>
  <span class='fu'>pheatmap</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/pheatmap/man/pheatmap.html'>pheatmap</a></span><span class='op'>(</span><span class='va'>sim</span><span class='op'>$</span><span class='va'>similarity</span><span class='op'>)</span>
<span class='op'>}</span>

<span class='co'># You already got the activities of signatures</span>
<span class='co'># in obj_suggested, however, you can still</span>
<span class='co'># try to optimize the result.</span>
<span class='co'># NOTE: the optimization step may not truly optimize the result!</span>
<span class='va'>expo</span> <span class='op'>&lt;-</span> <span class='fu'>bp_attribute_activity</span><span class='op'>(</span><span class='va'>e1</span>, return_class <span class='op'>=</span> <span class='st'>"data.table"</span><span class='op'>)</span>
<span class='va'>expo</span><span class='op'>$</span><span class='va'>abs_activity</span>

<span class='co'># Iterative extraction:</span>
<span class='co'># This procedure will rerun extraction step</span>
<span class='co'># for those samples with reconstructed catalog similarity</span>
<span class='co'># lower than a threshold (default is 0.95)</span>
<span class='va'>e2</span> <span class='op'>&lt;-</span> <span class='fu'>bp_extract_signatures_iter</span><span class='op'>(</span>
  <span class='fu'><a href='https://rdrr.io/r/base/t.html'>t</a></span><span class='op'>(</span><span class='va'>simulated_catalogs</span><span class='op'>$</span><span class='va'>set1</span><span class='op'>)</span>,
  range <span class='op'>=</span> <span class='fl'>9</span><span class='op'>:</span><span class='fl'>11</span>,
  n_bootstrap <span class='op'>=</span> <span class='fl'>5</span>,
  n_nmf_run <span class='op'>=</span> <span class='fl'>5</span>,
  sim_threshold <span class='op'>=</span> <span class='fl'>0.99</span>
<span class='op'>)</span>
<span class='va'>e2</span>
<span class='co'># When the procedure run multiple rounds</span>
<span class='co'># you can cluster the signatures from different rounds by</span>
<span class='co'># the following command</span>
<span class='co'># bp_cluster_iter_list(e2)</span>

<span class='co'>## Extra utilities</span>
<span class='va'>rank_score</span> <span class='op'>&lt;-</span> <span class='fu'>bp_get_rank_score</span><span class='op'>(</span><span class='va'>e1</span><span class='op'>)</span>
<span class='va'>rank_score</span>
<span class='va'>stats</span> <span class='op'>&lt;-</span> <span class='fu'>bp_get_stats</span><span class='op'>(</span><span class='va'>e2</span><span class='op'>$</span><span class='va'>iter1</span><span class='op'>)</span>
<span class='co'># Get the mean reconstructed similarity</span>
<span class='fl'>1</span> <span class='op'>-</span> <span class='va'>stats</span><span class='op'>$</span><span class='va'>stats_sample</span><span class='op'>$</span><span class='va'>cosine_distance_mean</span>
<span class='co'># }</span>
</pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by <a href='https://orcid.org/0000-0001-9855-7357'>Shixiang Wang</a>, Ziyu Tao, Huimin Li, Tao Wu, <a href='https://orcid.org/0000-0002-7736-0077'>Xue-Song Liu</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


